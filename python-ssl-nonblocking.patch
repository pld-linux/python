diff -ur Python-2.4.3.org/Lib/test/test_socket_ssl.py Python-2.4.3/Lib/test/test_socket_ssl.py
--- Python-2.4.3.org/Lib/test/test_socket_ssl.py	2003-07-01 16:49:32.000000000 +0200
+++ Python-2.4.3/Lib/test/test_socket_ssl.py	2006-03-30 22:23:37.724691000 +0200
@@ -27,6 +27,19 @@
     buf = f.read()
     f.close()
 
+def test_timeout():
+    test_support.requires('network')
+
+    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
+    s.settimeout(30.0)
+    # connect to service which issues an welcome banner (without need to write anything)
+    s.connect(("gmail.org", 995))
+    ss = socket.ssl(s)
+    # read part of return welcome banner twice,# read part of return welcome banner twice
+    ss.read(1)
+    ss.read(1)
+    s.close()
+					    
 def test_rude_shutdown():
     try:
         import thread
@@ -63,6 +76,7 @@
         raise test_support.TestSkipped("socket module has no ssl support")
     test_rude_shutdown()
     test_basic()
+    test_timeout()
 
 if __name__ == "__main__":
     test_main()
diff -ur Python-2.4.3.org/Modules/_ssl.c Python-2.4.3/Modules/_ssl.c
--- Python-2.4.3.org/Modules/_ssl.c	2006-02-13 01:37:09.000000000 +0100
+++ Python-2.4.3/Modules/_ssl.c	2006-03-30 22:25:51.753067250 +0200
@@ -468,6 +468,7 @@
 	int len = 1024;
 	int sockstate;
 	int err;
+	int pending;
 
 	if (!PyArg_ParseTuple(args, "|i:read", &len))
 		return NULL;
@@ -475,14 +476,20 @@
 	if (!(buf = PyString_FromStringAndSize((char *) 0, len)))
 		return NULL;
 
-	sockstate = check_socket_and_wait_for_timeout(self->Socket, 0);
-	if (sockstate == SOCKET_HAS_TIMED_OUT) {
-		PyErr_SetString(PySSLErrorObject, "The read operation timed out");
-		Py_DECREF(buf);
-		return NULL;
-	} else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {
-		PyErr_SetString(PySSLErrorObject, "Underlying socket too large for select().");
-		return NULL;
+	Py_BEGIN_ALLOW_THREADS
+	pending = SSL_pending(self->ssl);
+	Py_END_ALLOW_THREADS
+	
+	if (!pending) {
+		sockstate = check_socket_and_wait_for_timeout(self->Socket, 0);
+		if (sockstate == SOCKET_HAS_TIMED_OUT) {
+			PyErr_SetString(PySSLErrorObject, "The read operation timed out");
+			Py_DECREF(buf);
+			return NULL;
+		} else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {
+			PyErr_SetString(PySSLErrorObject, "Underlying socket too large for select().");
+			return NULL;
+		}
 	}
 	do {
 		err = 0;
