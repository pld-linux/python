--- Python-2.4.2/Doc/info/Makefile~	2003-07-16 06:02:58.000000000 +0200
+++ Python-2.4.2/Doc/info/Makefile	2006-03-26 13:37:34.000000000 +0200
@@ -34,10 +34,10 @@
 
 check-emacs-version:
 	@v="`$(EMACS) --version 2>&1 | egrep '^(GNU |X)Emacs [12]*'`"; \
-	if `echo "$$v" | grep '^GNU Emacs 21' >/dev/null 2>&1`; then \
+	if `echo "$$v" | grep '^GNU Emacs 2[1-9]' >/dev/null 2>&1`; then \
 	  echo "Using $(EMACS) to build the info docs"; \
 	else \
-	  echo "GNU Emacs 21 is required to build the info docs"; \
+	  echo "GNU Emacs 2[1-9] is required to build the info docs"; \
 	  echo "Found $$v"; \
 	  false; \
 	fi
--- Python-2.4.2/Doc/tools/mkinfo~	2003-09-29 19:26:08.000000000 +0200
+++ Python-2.4.2/Doc/tools/mkinfo	2006-03-26 13:52:20.000000000 +0200
@@ -61,5 +61,5 @@
 
 # generate the .info files:
 
-run $MAKEINFO --footnote-style end --fill-column 72 \
+run $MAKEINFO --footnote-style end --fill-column 72 --no-split \
 	      --paragraph-indent 0 --output=$INFONAME $TEXINAME
--- Python-2.4.2/Doc/lib/liboptparse.tex.old	2005-07-22 03:54:54.000000000 +0200
+++ Python-2.4.2/Doc/lib/liboptparse.tex	2006-03-26 20:53:48.000000000 +0200
@@ -100,8 +100,8 @@
 single letter, e.g. \code{"-x"} or \code{"-F"}.  Also, traditional \UNIX{}
 syntax allows multiple options to be merged into a single argument,
 e.g.  \code{"-x -F"} is equivalent to \code{"-xF"}.  The GNU project
-introduced \code{"-{}-"} followed by a series of hyphen-separated words,
-e.g. \code{"-{}-file"} or \code{"-{}-dry-run"}.  These are the only two option
+introduced \code{"--"} followed by a series of hyphen-separated words,
+e.g. \code{"--file"} or \code{"--dry-run"}.  These are the only two option
 syntaxes provided by \module{optparse}.
 
 Some other option syntaxes that the world has seen include:
@@ -170,7 +170,7 @@
 prog -v --report /tmp/report.txt foo bar
 \end{verbatim}
 
-\code{"-v"} and \code{"-{}-report"} are both options.  Assuming that
+\code{"-v"} and \code{"--report"} are both options.  Assuming that
 \longprogramopt{report} takes one argument, \code{"/tmp/report.txt"} is an option
 argument.  \code{"foo"} and \code{"bar"} are positional arguments.
 
@@ -256,7 +256,7 @@
 \end{verbatim}
 
 Each option has one or more option strings, such as \code{"-f"} or
-\code{"-{}-file"}, and several option attributes that tell \module{optparse} what to
+\code{"--file"}, and several option attributes that tell \module{optparse} what to
 expect and what to do when it encounters that option on the command
 line.
 
@@ -287,7 +287,7 @@
 \method{parse{\_}args()} returns two values:
 \begin{itemize}
 \item {} 
-\code{options}, an object containing values for all of your options{---}e.g. if \code{"-{}-file"} takes a single string argument, then
+\code{options}, an object containing values for all of your options{---}e.g. if \code{"--file"} takes a single string argument, then
 \code{options.file} will be the filename supplied by the user, or
 \code{None} if the user did not supply that option
 
@@ -366,7 +366,7 @@
 
 If you don't supply a destination, \module{optparse} figures out a sensible default
 from the option strings: if the first long option string is
-\code{"-{}-foo-bar"}, then the default destination is \code{foo{\_}bar}.  If there
+\code{"--foo-bar"}, then the default destination is \code{foo{\_}bar}.  If there
 are no long option strings, \module{optparse} looks at the first short option
 string: the default destination for \code{"-f"} is \code{f}.
 
@@ -483,7 +483,7 @@
                        "or expert [default: %default]")
 \end{verbatim}
 
-If \module{optparse} encounters either \code{"-h"} or \code{"-{}-help"} on the command-line,
+If \module{optparse} encounters either \code{"-h"} or \code{"--help"} on the command-line,
 or if you just call \method{parser.print{\_}help()}, it prints the following to
 standard output:
 \begin{verbatim}
@@ -568,7 +568,7 @@
 
 Note that \code{"{\%}prog"} is expanded just like it is in \code{usage}.  Apart
 from that, \code{version} can contain anything you like.  When you supply
-it, \module{optparse} automatically adds a \code{"-{}-version"} option to your parser.
+it, \module{optparse} automatically adds a \code{"--version"} option to your parser.
 If it encounters this option on the command line, it expands your
 \code{version} string (by replacing \code{"{\%}prog"}), prints it to stdout, and
 exits.
@@ -695,7 +695,7 @@
 \item[\code{version} (default: \code{None})]
 A version string to print when the user supplies a version option.
 If you supply a true value for \code{version}, \module{optparse} automatically adds
-a version option with the single option string \code{"-{}-version"}.  The
+a version option with the single option string \code{"--version"}.  The
 substring \code{"{\%}prog"} is expanded the same as for \code{usage}.
 \item[\code{conflict{\_}handler} (default: \code{"error"})]
 Specifies what to do when options with conflicting option strings
@@ -711,7 +711,7 @@
 purpose: IndentedHelpFormatter and TitledHelpFormatter.
 \item[\code{add{\_}help{\_}option} (default: \code{True})]
 If true, \module{optparse} will add a help option (with option strings \code{"-h"}
-and \code{"-{}-help"}) to the parser.
+and \code{"--help"}) to the parser.
 \item[\code{prog}]
 The string to use when expanding \code{"{\%}prog"} in \code{usage} and
 \code{version} instead of \code{os.path.basename(sys.argv{[}0])}.
@@ -874,7 +874,7 @@
 If \member{type} is not supplied, it defaults to \code{string}.
 
 If \member{dest} is not supplied, \module{optparse} derives a destination from the
-first long option string (e.g., \code{"-{}-foo-bar"} implies \code{foo{\_}bar}).
+first long option string (e.g., \code{"--foo-bar"} implies \code{foo{\_}bar}).
 If there are no long option strings, \module{optparse} derives a destination from
 the first short option string (e.g., \code{"-f"} implies \code{f}).
 
@@ -911,7 +911,7 @@
                   action="store_const", const=2, dest="verbose")
 \end{verbatim}
 
-If \code{"-{}-noisy"} is seen, \module{optparse} will set
+If \code{"--noisy"} is seen, \module{optparse} will set
 \begin{verbatim}
 options.verbose = 2
 \end{verbatim}
@@ -956,7 +956,7 @@
 options.tracks.append(int("3"))
 \end{verbatim}
 
-If, a little later on, \code{"-{}-tracks=4"} is seen, it does:
+If, a little later on, \code{"--tracks=4"} is seen, it does:
 \begin{verbatim}
 options.tracks.append(int("4"))
 \end{verbatim}
@@ -1024,7 +1024,7 @@
 parser.add_option("--secret", help=SUPPRESS_HELP)
 \end{verbatim}
 
-If \module{optparse} sees either \code{"-h"} or \code{"-{}-help"} on the command line, it
+If \module{optparse} sees either \code{"-h"} or \code{"--help"} on the command line, it
 will print something like the following help message to stdout
 (assuming \code{sys.argv{[}0]} is \code{"foo.py"}):
 \begin{verbatim}
@@ -1120,7 +1120,7 @@
 \member{help}
 
 Help text to print for this option when listing all available options
-after the user supplies a \member{help} option (such as \code{"-{}-help"}).
+after the user supplies a \member{help} option (such as \code{"--help"}).
 If no help text is supplied, the option will be listed without help
 text.  To hide this option, use the special value \code{SUPPRESS{\_}HELP}.
 
@@ -1206,7 +1206,7 @@
 \begin{description}
 \item[\code{has{\_}option(opt{\_}str)}]
 Return true if the OptionParser has an option with 
-option string \code{opt{\_}str} (e.g., \code{"-q"} or \code{"-{}-verbose"}).
+option string \code{opt{\_}str} (e.g., \code{"-q"} or \code{"--verbose"}).
 \item[\code{get{\_}option(opt{\_}str)}]
 Returns the Option instance with the option string \code{opt{\_}str}, or
 \code{None} if no options have that option string.
@@ -1267,7 +1267,7 @@
 At this point, \module{optparse} detects that a previously-added option is already
 using the \code{"-n"} option string.  Since \code{conflict{\_}handler} is
 \code{"resolve"}, it resolves the situation by removing \code{"-n"} from the
-earlier option's list of option strings.  Now \code{"-{}-dry-run"} is the
+earlier option's list of option strings.  Now \code{"--dry-run"} is the
 only way for the user to activate that option.  If the user asks for
 help, the help message will reflect that:
 \begin{verbatim}
@@ -1286,7 +1286,7 @@
 parser.add_option("--dry-run", ..., help="new dry-run option")
 \end{verbatim}
 
-At this point, the original \programopt{-n/-{}-dry-run} option is no longer
+At this point, the original \programopt{-n/--dry-run} option is no longer
 accessible, so \module{optparse} removes it, leaving this help text:
 \begin{verbatim}
 options:
@@ -1440,8 +1440,8 @@
 is the option string seen on the command-line that's triggering the
 callback.  (If an abbreviated long option was used, \code{opt{\_}str} will
 be the full, canonical option string{---}e.g. if the user puts
-\code{"-{}-foo"} on the command-line as an abbreviation for
-\code{"-{}-foobar"}, then \code{opt{\_}str} will be \code{"-{}-foobar"}.)
+\code{"--foo"} on the command-line as an abbreviation for
+\code{"--foobar"}, then \code{opt{\_}str} will be \code{"--foobar"}.)
 \item[\code{value}]
 is the argument to this option seen on the command-line.  \module{optparse} will
 only expect an argument if \member{type} is set; the type of \code{value}
@@ -1592,14 +1592,14 @@
 provide any built-in capabilities for it.  And you have to deal with
 certain intricacies of conventional \UNIX{} command-line parsing that \module{optparse}
 normally handles for you.  In particular, callbacks should implement
-the conventional rules for bare \code{"-{}-"} and \code{"-"} arguments:
+the conventional rules for bare \code{"--"} and \code{"-"} arguments:
 \begin{itemize}
 \item {} 
-either \code{"-{}-"} or \code{"-"} can be option arguments
+either \code{"--"} or \code{"-"} can be option arguments
 
 \item {} 
-bare \code{"-{}-"} (if not the argument to some option): halt command-line
-processing and discard the \code{"-{}-"}
+bare \code{"--"} (if not the argument to some option): halt command-line
+processing and discard the \code{"--"}
 
 \item {} 
 bare \code{"-"} (if not the argument to some option): halt command-line
@@ -1782,7 +1782,7 @@
 standard \code{append} action, but instead of taking a single value from
 the command-line and appending it to an existing list, \code{extend} will
 take multiple values in a single comma-delimited string, and extend an
-existing list with them.  That is, if \code{"-{}-names"} is an \code{extend}
+existing list with them.  That is, if \code{"--names"} is an \code{extend}
 option of type \code{string}, the command line
 \begin{verbatim}
 --names=foo,bar --names blah --names ding,dong
